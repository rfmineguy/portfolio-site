<!doctype html>
<html lang="en" data-bs-theme="dark">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <title>Blog - Generics Generator</title>
    <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.3/dist/css/bootstrap.min.css" rel="stylesheet" integrity="sha384-QWTKZyjpPEjISv5WaRU9OFeRpok6YctnYmDr5pNlyT2bRjXh0JMhjY6hW+ALEwIH" crossorigin="anonymous">
    <link href="main.css" rel="stylesheet">
    <link rel="icon" type="image/png" href="https://rfmineguy.github.io/portfolio-site/assets/images/favicon/favicon-96x96.png" sizes="96x96" />
    <link rel="icon" type="image/svg+xml" href="https://rfmineguy.github.io/portfolio-site/assets/images/favicon/favicon.svg" />
    <link rel="shortcut icon" href="https://rfmineguy.github.io/portfolio-site/assets/images/favicon/favicon.ico" />
    <link rel="apple-touch-icon" sizes="180x180" href="https://rfmineguy.github.io/portfolio-site/assets/images/favicon/apple-touch-icon.png" />
    <meta name="apple-mobile-web-app-title" content="MyWebSite" />
  </head>
  <body>
		<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.11.1/styles/default.min.css">
		<link rel="stylesheet" href="https://unpkg.com/@highlightjs/cdn-assets@latest/styles/dark.min.css">
    <script src="https://cdn.jsdelivr.net/npm/bootstrap@5.3.3/dist/js/bootstrap.bundle.min.js" integrity="sha384-YvpcrYf0tY3lHB60NNkmXc5s9fDVZLESaAA55NDzOxhy9GkcIdslK1eN7N6jIeHz" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@popperjs/core@2.11.8/dist/umd/popper.min.js" integrity="sha384-I7E8VVD/ismYTF4hNIPjVp/Zjvgyol6VFvRkX/vR+Vc4jQkC+hVqc2pM8ODewa9r" crossorigin="anonymous"></script>
		<script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.11.1/highlight.min.js"></script>
		<script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.11.1/languages/bash.min.js"></script>
		<script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.11.1/languages/yml.min.js"></script>
		<script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.11.1/languages/javascript.min.js"></script>
		

    <script type="text/javascript" src="src/template.js"></script>
  </body>
</html>

<header data-bs-theme="dark">
	<div id="heading-data-container">
		<!-- Filled in dynamically by javascript -->
	</div>
  <div class="navbar navbar-dark bg-dark shadow-sm">
    <div class="container">
      <a href="#" class="navbar-brand d-flex align-items-center">
        <svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" fill="none" stroke="currentColor" stroke-linecap="round" stroke-linejoin="round" stroke-width="2" aria-hidden="true" class="me-2" viewBox="0 0 24 24"><path d="M23 19a2 2 0 0 1-2 2H3a2 2 0 0 1-2-2V8a2 2 0 0 1 2-2h4l2-3h6l2 3h4a2 2 0 0 1 2 2z"/><circle cx="12" cy="13" r="4"/></svg>
        <strong>Riley Fischer</strong>
      </a>
      <button class="navbar-toggler" type="button" data-bs-toggle="collapse" data-bs-target="#navbarHeader" aria-controls="navbarHeader" aria-expanded="false" aria-label="Toggle navigation">
        <span class="navbar-toggler-icon"></span>
      </button>
    </div>
  </div>
</header>

<main>
	<div id="blog-container">
			<!-- Filled in dynamically by javascript -->
	</div>
</main>

<script type="module">
		/* Include the template library
		*/
		await include_templatelib('templatelib.html', ['blog-header', 'blog-entry', 'blog-p', 'main-heading', 'blog-code']);

		emit((() => template('main-heading', {}))(), 'heading-data-container')
		
		emit((() => template('blog-header', {
			title: "Generics Generator",
			description: "My journey through the development of this tool",
		}))(), 'blog-container')

		emit((() => template('blog-entry', {
			title: "Preface",
			body: [
				() => template('blog-p', {
					content: `
						Welcome! I'm glad you're interested in this blog about my generics generator project! It's been a really interesting journey getting to the point I'm at with it, and I will share that here.<br>
						<br>
						There are two main timelines discussed here:<br>
						<ul>
							<li>Generics Generator in Zig</li>
							<li>Generics Generator in C</li>
						</ul>
						<br>
						You will understand why there are two by the end of this blog.<br>
						<br>
						Enjoy!
					`
				}),
			]
		}))(), 'blog-container')

		emit((() => template('blog-entry', {
			title: "So Why Generics Generator?",
			body: [
				() => template('blog-p', {
					content: `
						As a C programmer that came from C++, I've always felt that generic datastructures were kind of a pain in the butt to use.
						You'd have to rewrite the <u><em>exact</em></u> same code for every underlying data type you want to use, and while it works I
						thought that wasn't a reasonable way to solve the problem. So for the past few months I've been working on a solution to that problem.
					`
				}),
				() => template('blog-p', {
					content: `
						My journey to the solution wasn't a straight path however, and that's the store this blog will tell.
					`
				})
			]
		}))(), 'blog-container')

		emit((() => template('blog-entry', {
			title: "The Idea",
			body: [
				() => template('blog-p', {
					content: `
						The initial thoughts was that it would be a command line driven tool. It would look in a specified search directory for files labeled with the <code>.tpl</code> extention.
						This file would define what that template was for: the source template files, the replacements, and the dependencies.<br>
						<br>
						For every new template you wanted to make you would write a new <code>.tpl</code> file and put it in the search directory, then voila it is now a template that can be generated.<br>
						<br>
						I didn't know it at the time, but this method wouldn't work very well when used in existing C build toolchains like Makefile, Cmake, Meson, etc.<br>
					`
				})
			]
		}))(), 'blog-container')

		emit((() => template('blog-entry', {
			title: "How Does It Work",
			body: [
				() => template('blog-p', {
					content: `
						The zig version worked purely off a command line interface. However the way it does so is pretty flexible.<br>
						<br>
						Templates can be put anywhere in your filesystem you wish, as generics-generator-zig allows you to specify where your templates are located via a shell environment variable <code>GEN_TEMPLATE_PATH</code><br>
						It will look for files ending in <code>.tpl</code> in whatever path you set that variable to.<br>
						<br>
						When it finds a file matching that description it will read it, and be able to give you all the information you need in order to fill out the replacements you specified (more on this later).<br>
						<br>
						You can now pass different values into the template and it will generate a file with the contents of your template except now it is filled out with those replacements.<br>
						<br>
						Additionally, each template has the option to define another template to be a dependency. This is to allow for situations where you might want to use another datastructure youve written as a template in another template.<br>
						<br>
						For example, you could implement a <code>queue</code> that utlizes a <code>linkedlist</code> and have the corresponding linked list generate alongside the queue.<br>
					`
				}),
				() => template('blog-p', {
					content: `
						Now what do these template files I'm speaking of look like? Lets go over that.<br>
						<br>
						The followng example will include all the features of the program to demonstrate as much as possible.<br>
						<hr>
						<h5>Example Template File</h5>
					`
				}),
				() => template('blog-code', {
				language: 'toml',
				code:
					`
						name = "queue"
						generators = ["queue.htpl", "queue.ctpl"]
						outformat = "queue_T"
						[deps.linked_list]
						datatype = "datatype-type"
						free = "free"

						[args.datatype-name]
						symbol = "$T"

						[args.datatype-type]
						symbol = "@T"

						[args.free]
						symbol = "FREE"
						default = "free"

						[args.print]
						symbol = "PRINT"
						default = "printf"

						[args.calloc]
						symbol = "CALLOC"
						default = "calloc"

						[args.realloc]
						symbol = "REALLOC"
						default = "realloc"

						[args.header]
						symbol = "HEADER_INCLUDE"
						default = "stdint.h"
					`
				}),
				() => template('blog-p', {
					content: `
						<ul>
							<li><b>name</b> -> defines the name of this template (this field would be used to identify this template from the cli)
							<li><b>generators</b> -> defines the list of files that are used to generate the output files (this contains the content of the template)
							<li><b>outformat</b> -> defines the format string for how the output files should be named
								<ul>
									<li>In this case it is saying to output the file using whatever was specified for the 'datatype' argument
								</ul>
							<li><b>deps</b> -> defines what other templates this template depends on and how to construct it
								<ul>
									<em>Each entry defines a rule on how to forward args to the dependent.</em>
									<li>The <code>datatype</code> argument for <code>linked_list</code> will be given the value that the <code>datatype-type</code> argument was given for <code>queue</code></li>
								</ul>
							<li><b>args</b> -> defines what the variables for the template are (this is the meat of the tool)
								<ul>
									<li><b>datatype</b> -> the datatype argument here is given the symbol <b>T</b> with no default replacement. This makes it a <em>required</em> argument on the cli.
									<li><b>free</b> -> the free argument here is given the symbol <b>FREE</b> with a default replacement of <b>free</b>. This makes it an <em>optional</em> argument on the cli.
									<li><b>print</b> -> the print argument here is given the symbol <b>PRINT</b> with a default replacement of <b>printf</b>. This makes it an <em>optional</em> argument on the cli.
								</ul>
						</ul>
					`
				}),
				() => template('blog-p', {
					content: `
					<hr>
						I still think that this is generally a good way of describing a template via a file, however the fact that it is a file ended up being the main problem. It meant that you have to keep around this file along with the specific generator files that were used by this template.
					`
				}),
			]
		}))(), 'blog-container')

		emit((() => template('blog-entry', {
			title: "Demo",
			body: [
				() => template('blog-p', {
					content: `
						Next, I will give a demonstration of the workflow for the first zig version.<br>
						<br>
						First things first, you need to decide where your templates should live. This is configured via a shell environment variable <code>GEN_TEMPLATE_PATH</code>. If this value is not provided by default it uses the current working directory.<br>
						<br>
						If setup correctly the help output of generics-generator will now display all the templates it finds in the selected directory.
					`
				}),
				() => template('blog-code', {
					code:
						`
						  $ generics-generator --help
						  Generics generator
						  
						  Usage: generics-gen [COMMAND]
						  
						  Commands:
							  		linked_list
						`
				}),
				() => template('blog-p', {
					content: `
						Here we can see that it found a <code>linked_list</code> template! Furthermore each template has its own help message!<br>
						<br>
					`
				}),
				() => template('blog-code', {
					language: 'bash',
					code:
						`
						  $ generics-generator linked_list --help
						  Usage: generics-gen linked_list [OPTIONS]
						  Options:
						  -f, --free=             default = free
						  -p, --print=            default = printf
						  -d, --datatype=
						  -o, --outputdir=        default = .
						  -h, --help              Print this help and exit
						`
				}),
				() => template('blog-p', {
					content: `
						This linked list is from the same linked_list template I provided in the previous section, and you can see that all the provided args are part of the <code>linked_list</code> subcommand<br>
						<br>
						Also note that the <code>datatype</code> arg has no default value like the others, this is a required field.
						<br>
					`
				}),
			]
		}))(), 'blog-container')


		emit((() => template('blog-entry', {
			title: "Why It Didn't Work",
			body: [
				() => template('blog-p', {
					content: `
						Once I was done with the Zig version of generics generator I was finding it difficult to use! I realized that I hadn't thought about how it would be actually used in a codebase.<br>
						<br>
						The way it was structured didn't lend itself to working within the existing build process of a project (commonly Make or CMake) and this is how I originally intended it to be used. Because it required all the input as command line arguments, depending on how many parameters your template had it would make the build code really long, unweildy, and unreadable.<br>
						<br>
						There were ways to make it work, but they were quite cumbersom when you had many templates you needed to generate. Here's an example Makefile for it.
					`
				}),
				() => template('blog-code', {
					language: 'Makefile',
					code:
						`
						OUT_DIR   := out
						GEN_FILES := src/generated/linked_list_int.c \\
						             src/generated/linked_list_vec2.c \\
						             src/generated/binary_tree_int.c \\
						             src/generated/binary_tree_vec2.c \\
						             src/generated/hash_table_string_int.c \\
						             src/generated/vector_int.c \\
						             src/generated/stack_int.c

						TPL_OUTDIR := src/generated
						SOURCES    := src/main.c $(GEN_FILES)
						BIN        := main

						# Override the template search path to the local templates folder
						export GEN_TEMPLATE_PATH=templates

						.PHONY: template_gen
						.PHONY: clean always build
						always:
						  mkdir -p $(OUT_DIR)
						  mkdir -p $(TPL_OUTDIR)
						clean:
						  rm -r $(OUT_DIR)
						  rm -r $(TPL_OUTDIR)
						build: always template_gen $(OUT_DIR)/$(BIN)

						$(OUT_DIR)/$(BIN): $(SOURCES)
							gcc $^ -o $@ -Isrc -Isrc/generated -ggdb

						template_gen: $(GEN_FILES)
						$(TPL_OUTDIR)/linked_list_int.c $(TPL_OUTDIR)/linked_list_int.h: templates/linked_list.tpl templates/linked_list.htpl templates/linked_list.ctpl
						  generics-generator linked_list --datatype=int --outputdir=$(TPL_OUTDIR)

						$(TPL_OUTDIR)/linked_list_vec2.c $(TPL_OUTDIR)/linked_list_vec2.h: templates/linked_list.tpl templates/linked_list.htpl templates/linked_list.ctpl
						  generics-generator linked_list --datatype=vec2 --header="vec2.h" --outputdir=$(TPL_OUTDIR)

						$(TPL_OUTDIR)/binary_tree_int.c $(TPL_OUTDIR)/binary_tree_int.h: templates/binary_tree.tpl templates/binary_tree.htpl templates/binary_tree.ctpl
						  generics-generator binary_tree --datatype=int --outputdir=$(TPL_OUTDIR)

						$(TPL_OUTDIR)/binary_tree_vec2.c $(TPL_OUTDIR)/binary_tree_vec2.h: templates/binary_tree.tpl templates/binary_tree.htpl templates/binary_tree.ctpl
						  generics-generator binary_tree --datatype=vec2 --header="vec2.h" --outputdir=$(TPL_OUTDIR)

						$(TPL_OUTDIR)/hash_table_string_int.c $(TPL_OUTDIR)/hash_table_string_int.h: templates/hash_table.tpl templates/hash_table.htpl templates/hash_table.ctpl
						  generics-generator hash_table --key-name="string" --key-type="const char*" --val-name="int" --val-type="int" --outputdir=$(TPL_OUTDIR)

						$(TPL_OUTDIR)/vector_int.c $(TPL_OUTDIR)/vector_int.h: templates/vector.tpl templates/vector.htpl templates/vector.ctpl
						  generics-generator vector --datatype=int --outputdir=$(TPL_OUTDIR)

						$(TPL_OUTDIR)/stack_int.c $(TPL_OUTDIR)/stack_int.h: templates/stack.tpl templates/stack.htpl templates/stack.ctpl
						  generics-generator stack --datatype=int --outputdir=$(TPL_OUTDIR)`
				}),
				() => template('blog-p', {
					content:
					`
						<br>
						You can see here this is <em>very</em> repetitive Makefile code. There are 7 different targets that do nearly the same thing, but they are different enough to need <em>7</em> different targets!
						<br>
						On top of being repetitive, its just flat out hard to read and understand what's going on here! I won't break down how this works, but if any of you are Makefile nerds like me feel free to read it further.<br>
						<br>
						This probably doesn't need to be as verbose as I made it here but if you want to get incremental builds then this is what is needed for Makefile.<br>
						<br>
						So at this point I knew I had to take what I learned here and make a better, more useful version.<br>
						<br>
						<a href="https://github.com/rfmineguy/generics-generator">Generics Generator (Zig)</a>
					`
				}),
			]
		}))(), 'blog-container')

		emit((() => template('blog-entry', {
			title: "The Start of the C Version",
			body: [
				() => template('blog-p', {
					content: `
						Given everything described above, I felt that I needed to find another solution to this problem. So using all the knowledge I gained about what was good and not so good about the Zig version I started prototyping a new version.<br>
						<br>
						An important point of the c version was that it had to have feature parity with the Zig version. This requirement was really helpful because it allowed me to have a focus, and not accidentally expand the scope too far. The features that needed to stay are as follows:<br>
						<ol>
							<li>Ability to replace a given symbol with another (basic, without this its not the same concept anymore)</li>
							<li>Support for dependency templates</li>
							<li>Configuration of where templates live, and where the outputs go</li>
						</ol>
						The main extra requirement was that it must be simpler to use in a C/C++ project<br>
						<br>
						<h5>So how does it accomplish those goals?</h5>
						<ol>
							<li>The C version gets rid of the <code>.tpl</code> file entirely
							<li>It removes command line arguments entirely without losing configurability
							<li>It is written in a header-only style
							<li>All template configuration is done in C with a well defined API
						</ol>
						<br>
					`
				}),
			]
		}))(), 'blog-container')

		emit((() => template('blog-entry', {
			title: "Demo",
			body: [
				() => template('blog-p', {
					content: `
						The C version is completely code oriented. Everything can be written in a single <code>build.c</code> file.<br>
						<br>
						Let's write one here real quick, then we'll discuss what it means.<br>
						We'll write a build script that generates the same <code>queue</code> that we saw earlier.<br>
					`
				}),
				() => template('blog-code', {
					language: 'c',
					code: `
						#define GENGEN_IMPLEMENTATION 		// allows the implementation code to be compiled when <code>build.c</code> is compiled
						#include "gengen.h"

						int main() {
						  // Setup the queue template information
						  ctemplate queuetpl     = template_create();
						  template_addfile       (&queuetpl, "queue.htpl", "queue_$T.h");
						  template_addfile       (&queuetpl, "queue.ctpl", "queue_$T.c");
						  template_addreplacement(&queuetpl, "$T", NULL);
						  template_addreplacement(&queuetpl, "^T", NULL);
						  template_addreplacement(&queuetpl, "PRINTF", "printf");
						  template_addreplacement(&queuetpl, "FREE",   "free");
						  template_addreplacement(&queuetpl, "CALLOC", "calloc");
						  template_addreplacement(&queuetpl, "HEADER", "stdint.h");

						  // Setup the linked list template information
						  ctemplate lltpl      = template_create();
						  template_addfile       (&lltpl, "linkedlist.htpl", "linkedlist_$T.h");
						  template_addfile       (&lltpl, "linkedlist.ctpl", "linkedlist_$T.c");
						  template_addreplacement(&lltpl, "$T", NULL);
						  template_addreplacement(&lltpl, "^T", NULL);
						  template_addreplacement(&lltpl, "PRINTF", "printf");
						  template_addreplacement(&lltpl, "FREE",   "free");
						  template_addreplacement(&lltpl, "CALLOC", "calloc");
						  template_addreplacement(&lltpl, "HEADER", "stdint.h");

						  // Setup the forwarding table
						  forward_table fwd_q_ll = forward_table_create();
						  forward_table_forward(&fwd_q_ll, fwd(.symbol="$T", .as="$T"));
						  forward_table_forward(&fwd_q_ll, fwd(.symbol="^T", .as="^T"));

						  // Setup the dependency and specify how we forward to it (fwd_q_ll)
						  template_adddep(&queue, linkedlist, fwd_q_ll);

						  // Setup a specific replacement context for queue<int>
						  replacement queue_int = replacement_create();
						  replacement_add(&queue_int, "$T",  "int");
						  replacement_add(&queue_int, "^T",  "int");

						  // Setup a specific replacement context for queue<long>
						  replacement queue_long = replacement_create();
						  replacement_add(&queue_long, "$T",  "long");
						  replacement_add(&queue_long, "^T",  "long");

						  // Run the generators for the setup templates and replacements
						  generator_run(settings_custom(.search_paths=paths("demo_templates", "."), .outdir="."), linkedlist, ll_int);
						  generator_run(settings_custom(.search_paths=paths("demo_templates", "."), .outdir="."), linkedlist, ll_string);
						  generator_run(settings_custom(.search_paths=paths("demo_templates", "."), .outdir="."), queue     , queue_int);
						  generator_run(settings_custom(.search_paths=paths("demo_templates", "."), .outdir="."), queue     , queue_long);
						}
					`
				}),
				() => template('blog-p' ,{
					content: `
						<br>
						<h5>What does this mean?</h5>
						First we setup the <code>queue</code> template, then we setup the <code>linked_list</code> template.
						<ul>
							<li><b>template_create()</b> - Sets up an empty template context.</li>
							<li><b>template_addfile(...)</b> - Adds a new source file and specifies the output filename format</li>
							<li><b>template_addreplacement(...)</b> - Adds a new replacement that defines symbols and what they should be replaced with</li>
						</ul>

						<br>
						Next we setup the forwarding table that defines how the <code>linked_list</code> is going to get its required replacements.
						<ul>
							<li><b>forward_table_create()</b> - Sets up an empty forwarding table</li>
							<li><b>forward_table_forward(...)</b> - Adds a new forwarding rule to the forwarding table</li>
						</ul>

						<br>
						Next we tell the <code>queue</code> that it depends on the <code>linked_list</code> and what forwarding table should be used for generation.<br>
						<ul>
							<li><b>template_adddep(...)</b> - Adds another template as a dependency using a particular forwarding table</li>
						</ul>

						<br>
						Now we're done setting up the templates themselves. They know:
						<ul>
							<li>what symbols to expect and what they should be replaced with by default</li>
							<li>what templates they depend on (if any).</li>
						</ul>

						<br>
						We're almost done! And here comes the component that allows for extreme reusability.<br>
						We need to now setup the specific replacements for the different variants of a template we want.<br>
						<ul>
							<li><b>replacement_create()</b> - Sets up an empty replacement set</li>
							<li><b>replacement_add(...)</b> - Defines what a certain symbol should be replaced with</li>
						</ul>

						<br>
						Finally we're at the point where we can run the generator and create our final output files.
						<ul>
							<li><b>generator_run(...)</b> - Runs the generator with specified settings, a template, and a replacement
								<ul>
									<li><b>settings</b>
										<ul>
											<li><b>.search_paths[]</b> - Where should the generator search for the source template files</li>
											<li><b>.outdir</b> - Where should the generator put the output file</li>
											<li><b>.verbose</b> - Should the generator produce verbose output</li>
										</ul>
									</li>
								</ul>
							</li>
						</ul>
					`
				})
			]
		}))(), 'blog-container')

		emit((() => template('blog-entry', {
			title: "Conclusion",
			body: [
				() => template('blog-p', {
					content: `
						This journey of working on generics generator has been a very enjoyable one.<br>
						<br>
						One of the main concepts I learned is that 'you don't know what you don't know'<br>
						<br>
						It sounds cliche, but when I started this I had a good idea of what I wanted. I was convinced it was the perfect idea and design, but it wasn't until I finished the zig version that I realized the major oversights it had.<br>
						<br>
						With this knowledge I was able to make a version that works better for the target audience <em>and</em> is significanly simpler.<br>
						<br>
						Thank you for being interested in my development journey.<br>
						<br>
						To take a look at either project here are the github links.<br>
						<a href="https://github.com/rfmineguy/generics-generator">Generics Generator (Zig)</a><br>
						<a href="https://github.com/rfmineguy/generics-generator-c">Generics Generator (C)</a>
					`
				})
			]
		}))(), 'blog-container')

		hljs.highlightAll();
</script>

